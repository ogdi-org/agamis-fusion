@startuml emby-start
actor user
boundary client
control "HttpServer (A)" as server
collections AkkaHttpRoutes as routes
control "ContainerRegistry (SA)" as reg
control "Container (A)" as app
database FusionFS as fs

user -> client : launch application
client -> server : HTTP Request\n(/app/<appId>/bootstrap)
server -> routes : route request
routes -> reg : Boostrap app with Id(<appId>)
group "Application bootstrap process"
    create app
    reg -> app : bootstrap an app
    activate app
    app -> fs : get app files
    app <-- fs : app files
    app -> app : create socket at the right place (if needed and specified)
    app -> app : run emby
    activate app
    reg <-- app : notif back to registry
    reg -> reg : register app instance
    server <-- reg : notify back server
    server -> routes : clone & update routes to include app instance
    client <- server : HTTP Response
    server -> server : update behavior
end
client -> client : redirect to app
@enduml

@startuml emby-classic-interact
actor user
boundary client
control "HttpServer (A)" as server
collections AkkaHttpRoutes as routes
control "ContainerRegistry (SA)" as reg
control "Container (A)" as app
collections "SessionManager (SA)" as session
database FusionFS as fs

activate session
activate reg
activate app

user -> client : interact with app
client -> server : HTTP Request\n(/app/routing/<sessionId>/...{internal_route})
server -> routes : receive request and route it
routes -> reg : get ActorRef
routes <-- reg : ActorRef
note left
    Getting IP and finally proxying the request directly
    might be tricky, so software may forward the request
    object to container (Actor) that would subsequently
    act as the local proxy (to local UNIX socket)
end note
routes <-- app : port
routes -> app : forward local request\nto local container
app -> app : forward local request to right port/socket
activate app
app --> session : [optionaly] save session state
session --> fs : flush to file
routes <-- app : Proxied HTTP Response
deactivate app
server <-- routes
client <-- server : HTTP Response
user <-- client : Update state
@enduml

@startuml emby-terminate
actor user
boundary client
control "HttpServer (A)" as server
collections AkkaHttpRoutes as routes
control "ContainerRegistry (SA)" as reg
control "Container (A)" as app

activate app
activate reg

user -> client : terminate application
client -> server : HTTP Request\n(/app/<appId>/terminate)
server -> routes : route request
routes -> reg : Stop app with Id(<appId>)
note right of reg : User must own app instance\nor have authorization\nto end any instance
reg -> app : Stop app
destroy app
reg <-- app : notif back to registry
deactivate reg
reg -> reg : update behavior with new ActorRefs list
activate reg
server <-- reg : notify back server
client <- server : HTTP Response
client -> client : redirect to app
@enduml